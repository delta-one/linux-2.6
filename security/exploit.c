#include <linux/audit.h>
#include <linux/cred.h>
#include <linux/exploit.h>
#include <linux/printk.h>
#include <linux/ratelimit.h>
#include <linux/sched.h>

void _exploit(const char *id)
{
	/*
	 * This function needs to be super defensive/conservative, since
	 * userspace can easily get to it from several different contexts.
	 * We don't want it to become an attack vector in itself!
	 *
	 * We can assume that we're in process context, but spinlocks may
	 * be held, etc.
	 */

	struct task_struct *task = current;
	pid_t pid = task_pid_nr(task);
	uid_t uid = from_kuid(&init_user_ns, current_uid());
	char comm[sizeof(task->comm)];
#ifdef CONFIG_AUDIT
	struct audit_buffer *ab;
#endif

	get_task_comm(comm, task);

#ifdef CONFIG_AUDIT
	ab = audit_log_start(NULL, GFP_ATOMIC, AUDIT_ANOM_EXPLOIT);
	if (ab) {
		audit_log_format(ab, "exploit id=%s pid=%u uid=%u auid=%u ses=%u comm=",
			id, pid, uid,
			from_kuid(&init_user_ns, audit_get_loginuid(task)),
			audit_get_sessionid(task));
		audit_log_untrustedstring(ab, comm);
		audit_log_end(ab);
	}
#endif

	pr_warn_ratelimited("warning: possible %s exploit attempt by pid=%u uid=%u comm=%s\n",
		id, pid, uid, comm);
}
EXPORT_SYMBOL(_exploit);
